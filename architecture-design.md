# ENGR 301: Architectural Design and Proof-of-Concept

## Proof-of-Concept

The aim of an architectural proof-of-concept (spike or walking skeleton) is to demonstrate the technical feasibility of your chosen architecture, to mitigate technical and project risks, and to plan and validate your technical and team processes (e.g., build systems, story breakdown, Kanban boards, acceptance testing, deployment).

A walking skeleton is an initial technical attempt that will form the architectural foundation of your product. Since a walking skeleton is expected to be carried into your product, it must be completed to the quality standards expected for your final product. A walking skeleton should demonstrate all the technologies your program will rely on "end-to-end" &mdash; from the user interface down to the hardware.

In the context of ENGR 301, a walking skeleton does not need to deliver any business value to your project: the aim is technical validation and risk mitigation.


## Document

The aim of the architectural design document is to describe the architecture and high-level design of the system your group is to build, to identify any critical technical issues with your design, and to explain how you have addressed the highest rated technical and architectural risks. The architecture document should also demonstrate your understanding of architectural techniques and architectural quality, using tools and associated notations as necessary to communicate the architecture precisely, unambiguously and clearly in a written technical document.

Page specifications below are *limits not targets* and refer to the pages in the PDF generated from the markdown. Because the size of your document is necessarily limited, you should ensure that you focus your efforts on those architectural concerns that are most important to completing a successful system: if sections are at their page limit, indicate how many items would be expected in a complete specification.

The ENGR 301 project architecture design document should be based on the standard ISO/IEC/IEEE 42010:2011(E) _Systems and software engineering &mdash; Architecture description_, plus appropriate sections from ISO/IEC/IEEE 29148:2018(E) _Systems and software engineering &mdash; Life cycle processes &mdash; Requirements engineering_; ISO/IEC/IEEE 15289:2017 _Systems and software engineering &mdash; Content of life-cycle information items (documentation)_; ISO/IEC/IEEE 15288:2015 _Systems and software engineering &mdash; System life-cycle processes_; ISO/IEC/IEEE 12207:2017 _Systems and software engineering &mdash; Software life cycle processes_ and ISO 25010 SQuaRE; with notations from ISO/ISE 19501 (UML). In particular, Annex F of ISO/IEC/IEEE 15288 and Annex F of ISO/IEC/IEEE 12207. These standards are available through the Victoria University Library subscription to the [IEEE Xplore Digital Library](https://ieeexplore.ieee.org/) (e.g., by visiting IEEE Xplore from a computer connected to the University network).

The document should contain the sections listed below, and conform to the formatting rules listed at the end of this brief.

All team members are expected to contribute equally to the document and list their contributions in the last section of the document (please make sure that your continued contribution to this document can be traced in GitLab). You should work on your document in your team's GitLab repository in a directory called "M2_Architecture". If more than one team member has contributed to a particular commit, all those team member IDs should be included in the first line of the git commit message. ``git blame``, ``git diff``, file histories, etc. will be tools used to assess individual contributions, so everyone is encouraged to contribute individually (your contribution should be made to many sections of the document, rather than focusing on just a single section), commit early and commit often.

---

# ENGR 301 Project *NN* Architectural Design and Proof-of-Concept

**Authors:** a comma-separated list of the names of each member of the team.

## 1. Introduction

The Supercharged Cowrie project is expected to expand the current capability of the Cowrie honeypot server, which is utilized to bait cyber attacks. The Cowrie system logs attackers' behaviour to help inform the user how to be better prepared for future attacks, when designing other systems.

### Client

Client Contact Details: <br>
Client:  Masood Mansoori, PhD. M.Sc. B.Sc. <br>
Email: masood.mansoori@vuw.ac.nz <br>
Work Phone: 04 886 5369 <br>
University Office: CO 130, Cotton Building <br>

### 1.1 Purpose

The purpose of this project is to extend the functionality of the Cowrie system. The purpose of the extensions is to simulate functions of a real operating system, to entice cyber attacks and log the data generated by these attacks.

### 1.2 Scope

The scope of the Supercharged Cowrie project will be fairly elementary. The Client has stated they do not wish for a fully-fledged editor, with reliance on external libraries; but rather an editor that runs on basic script and can fulfill basic editing functionalities. These functionalities include typical commands taht come with simulating an operating system, for example: nano, pwd, mkdir, whoami etc.

### 1.3 Changes to requirements

The original project requirements states that we will be implementing the whoami command along with the editor. However, since then, we have dicovered that the whoami command has already been dynamically implemented. Because of this, we have decided to implement the "locate" command instead of the whoami command. We have gotten approval from the client to do this. 
The new and current requirements are now: Implementing an editor, Implementing the locate command.
The locate command is used to search for files and directories by their names. The locate command will print the absolute path of all files and directories that matches the search pattern and for which the user has read permissions.


## 2. References

References to other documents or standards. Follow the IEEE Citation Reference scheme, available from the [IEEE website](https://ieee-dataport.org/sites/default/files/analysis/27/IEEE%20Citation%20Guidelines.pdf) (PDF; 20 KB). (1 page, longer if required)

## 3. Architecture

Describe your system's architecture according to ISO/IEC/IEEE 42010:2011(E), ISO/IEC/IEEE 12207, ISO/IEC/IEEE 15289 and ISO/IEC/IEEE 15288.

Note in particular the note to clause 5 of 42010:

_"The verb include when used in Clause 5 indicates that either the information is present in the architecture description or reference to that information is provided therein."_

This means that you should refer to information (e.g. risks, requirements, models) in this or other documents rather than repeat information.

### 3.1 Stakeholders

See ISO/IEC/IEEE 42010 clause 5.3 and ISO/IEC/IEEE 12207 clause 6.4.4.3(2).

For most systems this will be about 2 pages, including a table mapping concerns to stakeholder.

For this project, our stakeholders will be:
| Stakeholder  | Role |
| ------------- | ------------- |
| Team members  | Developing Cowrie |
| Masood Mansoori | Client |
| Project Manager  | Project Manager |
| Jesse Wood | Tutor |
| Winston Seah  | Owner |
| User  | Using end product |


| Stakeholder  | Main Concern |
| ------------- | ------------- |
| Team members  | Developing Cowrie to meet Client requirements on time  |
| Masood Mansoori  | Team producing the correct end product  |
| Project Manager  | Managing the team's communication and progress  |
| Jesse Wood  | Ensuring team is informed and aware of requirements  |
| Winston Seah  | Ensuring the team satisfies the client's requirements and expectations  |
| Users  |  Results of the final product  |

### 3.2 Architectural Viewpoints

Physical Viewpoint: Concerned with the topology of the systems components on the physical layer. <br>
Logical Viewpoint: Concerned with the abstracted funcionality of the system to the end users <br>
Development Viewpoint: Concerned with the this is about the development of the system from the programmers point of view. <br>
Process Viewpoint: Concerned with the run time processes of the system, and how these work together <br>
Scenarios: Using use cases to describe interactions with processes and objects. Use cases are important to help ensure the system will work upon completion. <br>


### 4. Architectural Views

(5 sub-sections of 2 pages each sub-section, per 42010, 5.5, 5.6, with reference to Annex F of both 12207 and 15288) 

Describe your system's architecture in a series of architectural views, each view corresponding to one viewpoint.

You should include views from the following viewpoints (from Kruchten's 4+1 model):

 * Logical
 * Development
 * Process
 * Physical 
 * Scenarios - present scenarios illustrating how two of your most important use cases are supported by your architecture

As appropriate you should include the following viewpoints:

 * Circuit Architecture
 * Hardware Architecture

Each architectural view should include at least one architectural model. If architectural models are shared across views, refer back to the first occurrence of that model in your document, rather than including a separate section for the architectural models.

### 4.1 Logical
...

### 4.2 Development

The development view entails the system view from the programmers perspective. This represents the management revolving the software aspect of the Cowrie, and the reasoning behind these management decisions. This section consists of the following subsections

- Code Structure
- Version Control
- Testing
- Prototyping

### 4.2.1 Code Structure

- Forward arrows illustrate a dependancy - eg. Package1 -> Package2 means Package1 depends on Package2.
- Dashed lines illustrate modules within the package/directory in question
- Blue Rectangles illustrate directories/packages
- Green rectangles illustrate python modules

#### 4.2.1.1 Structure for Locate command

Considering there is already a source code/python module providing the implementation of basic Linux commands such as cd/echo etc. Preferably we will add our implementation of the locate command to the base.py file that is already located within Cowrie's source code files. There are already mechanisms built in place to interpret user input/commands from the user to pass these commands down as system arguments for the base.py file to manipulate and perform commands accordingly.

#### 4.2.1.2 Structure for Text Editor

The source code for the text editor command will be located within the directory cowrie/src/cowrie/commands/TextEditor. We have been given approval to utilise the python library "curses" from the client/primary stakeholder, to provide further assistance on simulating a text-based terminal environment for the text editor.

Considering the text based terminal environment would emulate a Graphical-User-Interface, the Model-View-Controller (MVC) design pattern has been used to structure the python modules and place them in their respective packages. 

The "View" package will be responsible for providing a text based terminal environment for the user, and will contain most of the visual logic within the editor.py module, such as location of cursor, size of window and visible buttons/widgets to display the shortcuts that can be used when in the environment.

The "Controller" package is responsible for manipulating user input/commands and providing necessary input for the Model package (which will consist of all the editing logic/additional text editing functionalities). For example the "Controller" package is responsible for reading keyboard input from the user within the text environment to update the position of a cursor, along with reading keyboard shortcuts performed by the user to summon certain features with the editing environment eg. Save, Cut and Paste etc.  

The "Model" package is responsible for other additional functionalities for the text editor. Such as having modules to enable saving files, writing to files etc. 

Each of these packages have been separated into two layers to further identify what package is dependant on another package. This has been implemented with the design rule that packages should only be dependant on other packages that are either within the same layer or in a layer below, to ensure there are some constraints to our structure. Hence Controller and Model have been placed in Layer 1, where it's responsibility revolves around both interpreting user input and the overall logic of the editor. 

Layer 2 will contain code/implementation of the Text Editing environment, and is dependant on the current state of the editing logic that is within the Model package. 


![](diagrams/package_diagram_without_classes.png)

*Figure 4.2.1.3 UML Package Diagram*

### 4.2.2 Version Control
To maintain good version control, we will be using Gitlab for this project. Gitlab allows us to use features such as branches, merge requests, issues and epics so that all team members can collaborate and contribute simultaneously while also keeping track of all changes and progress for the project. All project contributions on Gitlab will be done online. This means that all parts of the project will be backed up and easily accessible to team members at all times. 

We will be using branches on Gitlab for when different team members are working on different parts of the project. Each member will create and work on their own branch that will be created from the master branch. This will allow members to easily make contributions from their own devices at their convenience. Another benefit of using branches in Gitlab is that any branch containing mistakes or code with bugs will not be pushed onto the master branch, this means that members can experiment and try out different ways of completing their part of the project without worrying about any consequences it may have on already working part of the master branch. Once a member has finished with their branch, a merge request to the master branch will be committed. Another team member will review this merge request to check and approve it and will then merge it into the master branch.

Gitlab issues and epics will be used to break down the project into separate parts that team members will assign themselves to. This will allow us to keep track of the progress of the project by knowing what has been done, what is being done, and what is still left to do. Issues will also be used to discuss the implementation of ideas and elaborate on code implementations.

### 4.2.3 Testing
Our client has stated that they will be conducting the tests on our project once every two weeks during a meeting with all team members. The testing involves the client checking the accuracy of design and documentation as well as checking the correctness of the implementation and output. We will do this by using methods such as unit testing and acceptance testing. Walk-throughs and inspections will also be conducted for verification purposes. By using these methods, we can regularly ensure that we are meeting the clients expectations and we can receive feedback on what parts need improvements or changes made to them.  Walk throughs and inspections will allow us to discuss, explain and assess our individual contributions to the team and client. Team members, along with the client, can then make any suggestions and inspect specific parts that may need improving. Walkthrough and inspection meetings will involve the following procedure: Author (team member) explains what they have worked on, all other members inspect and point out any defects or possible improvements,  author makes changes according to what was inspected, changes will be checked at the next meeting. Everyone will get a turn to be the author. Consistent fortnightly meetings with the client and all team members will take place so that everyone is in agreement and is aware how the success of the project is tracking.

 Unit Testing will be frequently used to test parts of our implementation of the commands the client has asked for. Unit testing will essentially involve testing individual methods and making sure the method itself is correctly implemented and functions as expected. E.g  Testing a method for logins can check the user's credentials and will return true or false if they have logged in. The benefits of using unit testing is that it is time efficient, so it can be done often. 
 
 We will also be using acceptance testing. This will involve creating a set of tests that will ensure the team can produce the minimum viable product required by the client. (i.e text editor and locate command). These tests would involve ensuring that the text editor opens, and responds to the minimize or close button or, testing the locate command to ensure that it prints the correct file path etc. Acceptance testing will ensure that all the bare minimum functions work as expected to meet client requirements.

### 4.2.4 Prototyping
Our fortnightly meetings with the client will give us the chance to make small developments on prototypes of functional features and will also allow us to constantly provide updates and present these developments. This will be done using walk-throughs and inspections (refer to sub-section 4.2.3 above).  Doing this will keep the client informed on what has been completed and what still needs to be done or needs further attention. Our client will then have an opportunity to clarify and voice any feedback or opinions they may have so that changes can be made on prototypes early on.

...

### 4.3 Process

Attacker will try to hack the environment using SSH (on port 22), and this project will create the honeypot for the attackers to protect the system and study the behaviour of the attacker. It will provide the simulated environment, where an attacker assumes that he is accessing the actual environment. Any un-authorised access to the server using SSH will be forwarded to the Cowrie honeypot running on port 2222 using iptables or firewall. As it is depicted in the below diagram.

![](diagrams/process.png)

There are two scenarios when attacker will access the honeypot.

**First Time Attack:**

Whenever any attacker first time tries to access the honeypot. In this scenario, we can provide user a fresh environment and we don’t need to prepare too much for this. It would be the simplest solution.

**Returning Attack:**

In this scenario, an attacker comes back to exploits a system again then we need to make sure that:

1.	The attacker can see exactly the same changes to the file structure that he made in his previous session. Like create new folder, rename existing folder, delete any folder, create new file etc.
2.	Metadata (e.g., last modified owner, last modified files, last modified directories, last modified time etc) for files and directories should not be altered.
3.	There should not be noticeable delay in the response.
4.	The attacker should be able to see his all-historical commands as it is and in the same sequence, which he has performed by executing commands.
5.	There should not be any evidence where attacker should be able to observe that any commands has been replayed or re-executed.

Below diagram depicts the process architecture for Supercharged cowrie project
![](diagrams/Process_View_of_Cowrie_Project.png)

**Login Process:** It is an expternal process, and it is not part of our implementation. This step is just to show the starting point of the interaction.

**Identification of Un-authorised Access Process:** This process will check for all of the SSH accesses, if any authorized person will try to acceess the system then it will not forwaard the login (SSH) request to the honeypot. Only un-authorised SSH requests will be forwaarded to the honeypot system.

**Honeypot Process:** It will accpets the SSH request and keep track of all of the actions specified above.

**Attacker's Actions Anslysis Process:** This process will study the actions performed by the attacker, so that we can find out any vulnerabilities in our system and make it robust.

#### Non-functional Requirements:
Non functional requirements can be splitted into multiple categories, as described below:

**1. High performance:** 
Supercharged Cowrie system should respond quickly Whenever any attacker tried to login. 
Also, if there are multiple attacks on the same time then system must be able to tackle all of the requests.

**2. User friendly:** 
Attacker should not be able to identify that he is trapped with the honeypot.

**3. Security:** Supercharged cowrie project should be able to indentify authorised and un-authorised access effieciently and any un-authorised access should not be allowed to access actual system.

**4. Failure tolerance:** The system should be fail proof and be able to recover and keep
working in a matter of seconds.

**5. Multiple profiles support:** Supercharged Cowrie Porject should be able to support multiple profiles for various IoT devices.

### 4.4 Physical 

Cowrie has been built as a virtual honeypot. Therefore, there is very little in terms of physical requirements for this project. It can be set up on any server or computer that has Python 3.7+ and Python-virtualenv installed and is connected to a network. This project does not require a database to be set up or backup servers to be in place, figure 4.4.1 shows that only a network connection is required for the virtual enviroment to opperate.

![](physical/physical_network.png)

*Figure 4.4.1: Physical blueprint*

The extensions that are being developed for Cowrie will utilise the same virtual environment that Cowrie is currently run within. This means that the extensions will use the systems and protocols within Cowrie to connect to a network and send and receive information. There are multiple areas within a network a honeypot should be set up as displayed in Figure 4.4.2. These include outside of the networks firewall, along side the service network servers and among the end users and main servers of the network. 
 
![](physical/network_diagram.png)

*Figure 4.4.2: Honeypots within a network*


### 4.5 Scenarios

The two main scenarios that have been highlighted, are Opening/Saving files using the text editor, and correct/dynamic output with regards to the "locate" command. Proper support for these two scenarios would ensure that our minimum viable product is completed.  

#### 4.5.1 Opening Files/Saving Files with the Text Editor

This scenario would also include use cases such as prompting a user to save the file they have made changes to, and prompting the user to rename the file if they please. 

**Actor**: Attacker <br>
**Actor's desire**: Attacker wants to be able to create script files and have them saved within the file system <br>
**Actor's reasoning**: To ensure that he/she is able to go back in the script and add content when necessary, eg. debugging the script by fixing code in the script, the actor wants to be able to save their progress to then be able to add content later.

**Acceptance Criteria**

1. User summons text environment with 'editor' command with a file
2. System opens text environment with the user's requested file opened
3. User adds content to the file and presses CTRL+X to save
4. Prompts user to rename and confirm they want to save
5. User responds with 'y' to the prompts
6. File is stored in the file system and system exits out of the text environment

![](use_cases/cowrie_use_case_text_editor.png)

*Figure 4.5.2 Scenario for Text Editor*

#### 4.5.3 User Executes Locate Command

This scenario has a very succinct process, as it is solely requiring the user to implement the command with a regex expression added onto it. For example expressions such as "*.sh" will allow the locate command to work with the expression to search through the file system for files with an extension of .sh. To avoid possible uncertainty - this will produce outputs of the absolute paths of these files in question, similar to how the 'locate' command operates in a Linux environment. 

**Actor**: Attacker <br>
**Actor's desires**: Attacker wants to use the locate command to spot any files with a particular extension eg. *.sh <br>
**Actor's reasoning**: Will allow attacker to keep track of the path of the scripts they are making. <br>

**Acceptance Criteria**

1. Attacker performs locate command with the regex expression *.sh to find all paths of their scripts
2. System parses through file system using string search, and prints out the absolute paths of the script files within the file system 

![](diagrams/use_case_locate.png)

*Figure 4.5.4 Scenario for 'whoami' command*

## 5. Development Schedule

Subsection 5.1 has been modified from the project requirements. Extra information and justifications of the project deliverable dates have been added.

### 5.1 Schedule


The following are the key dates for the project deliverables. These dates have been comfirmed in advance with the client and the client has given approval over email for these dates.

1. July 31st - Architectural Prototype 
1. August 19th - Minimum Viable Product (Text editor and locate command)
1. October 1st - Further Releases (Extra commands that will be implemented after further discussions with the client once the minimum viable product has been completed).

These dates have been selected according to the size of the project, skillset of the team and the clients requirements. Along with these dates, we will be following the agile method and having sprints every two weeks. By breaking down the project into smaller, achievable tasks, we will be able to increase the overall productivity of the team. Sprints will also allow us to accomodate any change requests that may occur since we will have more control over the project.


### 5.2 Budget and Procurement

The Supercharged Cowrie project is software based, therefore we do not require any physical equipment or resources outside of our reach to complete it. Therefore this project does not have a budget.

#### 5.2.1 Budget

Present a budget for the project (as a table), showing the amount of expenditure the project requires and the date(s) on which it will be incurred. Substantiate each budget item by reference to fulfilment of project goals (one paragraph per item).

(1 page). 

#### 5.2.2 Procurement

Present a table of goods or services that will be required to deliver project goals and specify how they are to be procured (e.g. from the School or from an external organisation). These may be software applications, libraries, training or other infrastructure, including open source software. Justify and substantiate procurement with reference to fulfilment of project goals, one paragraph per item.
(1 page).

### 5.3 Risks 

Risks  done by Shruti 

Risk: Tripping 
Likelihood: Likely 
Impact: Light - severe 
Can cause: Painful injuries resulting in members being unable to participate and contribute 
Mitigation: Ensure work areas and walkways are well-lit. Keep floor clear. Keep bags, cords etc under tables at all times. No running. Keep work area clutter free. 

Risk: Spending large amounts of time looking at the screen. 
Likelihood: Very likely 
Impact: Light - severe 
Can cause: headaches, blurry vision, dry eyes, and neck and shoulder pain 
Mitigation: Follow the 20-20-20 rule. Every 20 minutes look away from your screen and look at an object 20 feet away for at least 20 seconds. Practice regular breaks and avoid unnecessary screen use. 

Risk: Sitting at the desk for long periods of time. 
Likelihood: Very likely 
Impact: Moderate 
Can Cause: Bad posture, back pain. 
Mitigation: Educate members about their head position; try to keep the weight of the head directly above the neck. Encourage team members to take short walks

Risk: Papercuts 
Likelihood: Unlikely 
Impact: Light 
Can Cause: Bleeding, pain and discomfort 
Mitigation: Avoid using paper - it is not necessary for this project 

Risk: Lifting/carrying heavy items such as computer equipment or other personal belongings. 
Likelihood: Likely 
Impact: Moderate 
Can Cause: Injuries if something is dropped, muscle sprains and strains 
Mitigation: Position items so they are easily accessible for everyone. Provide assistance to members if required.[2] 

Risks done by Lucy 

Risk: RSI (Repeated Strain Injury) <br>
Likelihood: Likely <br>
Impact: Moderate - Severe <br>
Can Cause: Long term pain doing day to day tasks, inability to do select tasks, expenses in the form of medical appointments, loss of quality of life, potential of injury in other tasks increases, permanent damage to muscles and ligaments, more likely to develop sciatica, more likely to develop carpal tunnel. <br>
Mitigation: Maintain a good posture whilst sitting at a desk. Frequent small breaks to stretch and readjust position at desk, and monitor posture. Take regular breaks while doing long and or repetitive tasks. If you are stressed, try breathing exercises, and focus on relaxing muscles to avoid strain and cramp. Unclench your jaw often to avoid pain there. Keep wrists flat and straight while writing. If pain is beginning to occur, do not ignore it, instead get up, move around, and make sure someone else in the team is aware that you may be in pain. <br>

Risk: Contracting Covid-19 <br>
Likelihood: Very Likely <br>
Impact: Severe <br>
Can Cause: Widespread infection amongst the team, limiting ability to work on project. Can result in Long Covid in some individuals. Can also result in death if not treated properly. <br>
Mitigation: Wear masks at all times when social distancing is not possible, sanitize and wash hands before eating food, sanitize hands after coming into contact with door handles etc. Avoid touching each other (ie handshakes). Ensure that if you have symptoms of Covid-19 that you take a test immediately, and isolate and inform all team members immediately if the test is postive. If you test positive, follow all government and health instructions. Make sure to rest lots, and take breaks from screens. Do not push yourself to return to study, as pushing yourself too soon can increase the chance of developing long covid. <br>

Risk: Electrical Fires <br>
Likelihood: Unlikely <br>
Impact: Severe <br>
Can Cause: Burns, loss of equipment, loss of life, smoke inhalation, electrocution, damage to university property.<br>
Mitigation: Avoid overloading power points, ensure chargers and laptops are not being used on flammable surfaces, and monitor chargers, phones and laptops for overheating. Particularly those with metal framed laptops, monitor the health of the device, and the heat it is putting out. Familiarise selves with nearest C02 fire extinguisher (Carbon Dioxide extinguisher), and/or the nearest Dry Powder extinguisher. If an electrical fire is to occur, locate the nearest C02 or Dry Powder extinguisher, and follow instructions on the extinguisher. Ensure that someone on the team activates the nearest fire alarm. DO NOT USE WATER ON AN ELECTRICAL FIRE. <br>

Risk: Spillage of food & liquids <br>
Likelihood: Likely <br>
Impact: Moderate <br>
Can Cause: Damage to computers, sticky mess to clean up, slipping hazard, damage to university property, reduction in teams ability to work on project, damage to hard drives, loss of progress, electrical failures. <br>
Mitigation: No food near computers. Only drinks in sealed, spillproof containers. Only have water in a sealed spill proof bottle in the laboratories. If spillage does occur, ensure it is cleaned up immediately, and notify other team members of the spill. If possible, find a wet floor sign to put up near the spill, to avoid other people slipping.<br>

Risk: Stress/Arguments/Anger/Disagreements within the team. <br>
Likelihood: Very Likely <br>
Impact: Severe <br>
Can Cause: Physical confrontation amongst team members, hostility and emotional distress, inability to complete work as a team, a flawed end product, lasting resentment towards team members after the project has ended. Can damage team relationships, and  affect individual and team grades. Hostility between team members in front of client can jeopardise clients perception of the team. <br>
Mitigation: Be mindful of the way team interacts - mindful of body language, tone, and facial expressions. If tension is brewing, make sure to take a breather from working with whoever the tension is with, and step outside. Do nottry and resolve conflicts whilst emotional. If a problem occurs, let the team know, as it is important to resolve conflict before it escalates. Maintain good communication with the team. Be mindful of interactions around deadlines, as all team members will be feeling tense close to deadlines. Maintain clear and consistent communication in the lead up to any and all deadlines. If conflict cannot be resolved one to one with team mates, escalate up the hierachy to the team tutor, and further if needed. Best way to mitigate problems is to solve them as soon as they occur - do not allow conflict to fester and grow.<br>

### 5.4 Health and Safety

The team will manage computer related risks by following the mitigation strategies listed in the section above. To manage Occupational Over Use, team members will be aware to stop when they have any sort of disomfort, and take frequent breaks to adjust posture and hand placement. The team will be made aware of the correct positions for hands while typing, and correct posture for working at a desk. Frequent breaks will be the best way to manage risks of Occupational Over Use. 
The team will manage cables by ensuring that powerpoints are not overloaded, and computer charging cables are laid out in such a way that tangles should not happen. In the laboratories computer cables will be placed along places that are there to leave cables in. In the event that a team member needs an extra cable to be plugged into something, the team member will ensure that there is enough space in the plug socket without overloading it, and make sure that the cable is laid out correctly to ensure that the cables are managed correctly. 

The project does not require work or testing at any external workplaces or sites. All work is software based, and will take place in either the university computer laboratories, university libraries, university campus seating, or at the team members own place of residence. All team members will adhere to the university computer safety requirements while on campus, and adhere to safety guidelines around computer use when working at their own place of residence. 

The project does not require and human or animal testing. All software testing will be done within the team by the team members, and does not require Ethics Approval. 

For the duration of this project, the team is required to adhere to all university policies, government laws, and Covid-19 health orders. It is the responsibility of each team member to read through the possible risks of this project, and familiarise themselves with the mitigation strategies listed. The list of risk and mitigation strategies may not be inclusive, and all team members are encouraged to add to the list as they see fit.

#### 5.4.1 Safety Plans

Project requirements do not involve risk of death, serious harm, harm or injury

## 6. Appendices

### 6.1 Assumptions and dependencies 

 
Supercharged Cowrie Project has below listed Assumptions and dependancies

#### Assumptions:
1. Port (22) is enabled for SSH login.
1. "admin" user has permission to do SSH login.
1. Allwed to use basic linux commands, like: nano editor, pwd, whoami
1. "whoami" command is executable and returns expected outcome.
1. "userdb.txt" file content format would be "<USER_NAME>:<UESR_PASSWORD>"
1. Screen size/format would be as per the standard linux editors.
1. File editiing commands will be stored in a log file and its name will be Cowrie.log
1. Location of the "Cowrie.log" file will be /cowrie/var/cowrie.
1. Doesn't have specific hardware requirements.
1. Only file system will be used to store information rather than using any SQL (like MySQL, SQL Server etc.) or Non-SQL (Like: MongoDB, DyanmoDB etc.) database.
1. Customization would be required only for 'whoami' and 'nano' text editor in this project.

#### Dependancies:
1. Availability of Source code for 'Cowrie Honeypot Server' project for extension and enhancements.
1. Knowledge of the python language would be required. 
1. Location of the various log files would be dependent on the source code for 'Cowrie' Project.

### 6.2 Acronyms and abbreviations

Here is the list of Acronyms and abbreviations used in this document.

#### List of Acronyms

|Acronym  |	Category/ stands for |
|---------|----------------------|
|CEF | Common Event Format (Used for loggiing) |
|CLI | Command Line Interface |
|e.g. | Latin abbreviations |
|ECS | Engineering Computer Science |
|ENGR301 | Course Code used in Victoria University for Engineering stream. |
|Kbs | Knowledge based system |
|ssh or SSH | Secure Shell used for remote login to the linux server |
|UML | Unified Modeling Language |

#### List of abbreviations

|Abbreviation  | Stands/Used for |
|---------|----------------------|
|etc.|et cetera (means and so on)|
|i.e.|Id est (means that is) Used to clarify or specify something in parentheses|
|mkdir| Linux command to create new directoty |
|sync|Synchronization, synchronize| 
|nano| Linux Text Editor |
|whoami| Linux Command to see current User details|

## 7. Contributions

Lucy Carver: 5.3 (risks 6-10 inclusive), 5.4, 5.4.1, 3.2 <br>
Sridhar Venkatesh: 4.2.1, 4.2.1.1, 4.2.1.2 including code structure diagram, All of section 4.5 including diagram <br>
Thomas Yang: <br>
Selby Dasent: <br>
Shruti Raja: <br>
Deepika Raheja: 




---

## Formatting Rules 

 * Write your document using [Markdown](https://gitlab.ecs.vuw.ac.nz/help/user/markdown#gitlab-flavored-markdown-gfm) in your team's GitLab repository.
 * Major sections should be separated by a horizontal rule.


## Assessment 

This document will be weighted at 20% on the architectural proof-of-concept(s), and 80% on the architecture design.

The proof-of-concept will be assessed for coverage (does it demonstrate all the technologies needed to build your project?) and quality (with an emphasis on simplicity, modularity, and modifiability).

The document will be assessed by considering both presentation and content. Group and individual group members will be assessed by identical criteria, the group mark for the finished PDF and the individual mark on the contributions visible through `git blame`, `git diff`, file histories, etc. 

The presentation will be based on how easy it is to read, correct spelling, grammar, punctuation, clear diagrams, and so on.

The content will be assessed according to its clarity, consistency, relevance, critical engagement and a demonstrated understanding of the material in the course. We look for evidence these traits are represented and assess the level of performance against these traits. Inspection of the GitLab Group is the essential form of assessing this document. While being comprehensive and easy to understand, this document must be reasonably concise too. You will be affected negatively by writing a report with too many pages (far more than what has been suggested for each section above).

---
