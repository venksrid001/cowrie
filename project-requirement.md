# ENGR 301: Project Requirements Document

<div style="page-break-after: always;"></div>

# ENGR 301 Project Supercharged Cowrie Project Proposal and Requirements Document
#### Lucy Carver, Sridhar Venkatesh, Thomas Yang, Shruti Raja, Selby Dasent, Deepika Raheja

## 1. Introduction

The Supercharged Cowrie project is expected to expand the current capability of the Cowrie honeypot server, which is utilized to bait cyber attacks. The Cowrie system logs attackers' behaviour to help inform the user how to be better prepared for future attacks, when designing other systems. 

### Client

Client:  Masood Mansoori, PhD. M.Sc. B.Sc. <br>
Contact Details: <br>
Email: masood.mansoori@vuw.ac.nz <br>
Work Phone: 04 886 5369 <br>
University Office: CO 130, Cotton Building 

### 1.1 Purpose

The purpose of this project is to extend the functionality of the Cowrie system. The purpose of the extensions is to simulate functions of a real operating system, to entice cyber attacks and log the data generated by these attacks. 

### 1.2 Scope

The scope of the Supercharged Cowrie system will be fairly elementary. The Client has stated they do not wish for a fully-fledged editor, with reliance on external libraries; but rather an editor that runs on basic script and can fulfill basic editing functionalities. These functionalities include typical commands taht come with simulating an operating system, for example: nano, pwd, mkdir, whoami etc.

### 1.3 Product Overview 
#### 1.3.1 Product Perspective

Cowrie is a medium level interaction honeypot server, derived from Kippo. Kippo was another medium level interaction server developed with Python, which was primarily used to log brute force attacks and any sort of shell interaction performed by the attacker. Similar to Cowrie, Kippo also presents a fake file system for the attacker to work with. Along with a fake file system, Kippo also provides a file named userdb.txt, which allows the user of Kippo to edit any possible password and username combinations for the attacker to work with. This file can be overwritten and added to when necessary. The commands performed by an attacker (when logged into Kippo) are immediately captured and saved into a log file. Kippo also presents the utility to replay these log files at the live speed in which they were performed by the attacker.  

Kippo is no longer under active development, and most of its file structure, functionality and library dependancies have been utilised for the implementation of Cowrie. Cowrie is considered an extension of the functionalities of Kippo, as it is more capable of emulating the functionalities of an operating system and supports a wider range of commands. 

The Supercharged Cowrie project plans to implement specific commands and ensure that the Cowrie is able to provide dynamic output for those possible commands that an attacker may perform. Specifically the whoami command and the ability to provide a command line text editor that runs from its own script. The whoami command needs to produce expected results depending on whoever the attacker is logged in as. It is expected to create support for a text editor that runs from no library dependancies and is able to emulate the functionality of the nano editor (currently in Linux CLIs), while running off its own independant script. 


**User interfaces:** 

Operates within the command line interface. This Should allow for editing files within the command line for Windows and Unix certified systems. 

**CPU/Memory**

Memory usage has not been documented as of yet, however there is an existence of a meminfo file, to allow the attacker to monitor how the memory is being used whilst logged into Cowrie. Cowrie simulates the internal storage of different IoT devices to further enhance its simulation of the internal, configuration files and file structure. When an attacker wants to read the meminfo file, they will be provided with memory storage/CPU/OS from the IoT devices that have been simulated for Cowrie. Memory should be persistent to the extent that an attacker will be able to view a history of their previous commands performed whilst logged into Cowrie. There should also be (at least) metadata of the files that were created in the last session where the attacker previously logged on and there should be some trace of the data that was created by the attacker while logged into the honeypot. 



#### 1.3.2 Product Functions

Cowrie currently has a number of features that allow it to operate as a honeypot. The Supercharged Cowrie project will be expanding on these to improve its functionality. These functions will build off existing commands and utilities within a Unix system but be created to operate within Cowrie.

The first function will be a dynamic whoami command. This is a basic Unix and Windows command that is used within the CLI to display the username of who is logged in. Cowrie does currently have a response to the whoami command; however this command has a fixed response of root. To make this a dynamic response rather than a static response, the command will need to produce a response based off the username of who is logged in. This will improve the deceptiveness of the Cowrie honeypot for those that log into it. 

The second function that will be added is that of a CLI text editor. A common tactic for attackers when accessing a system is to open a text editor and edit/save a file, if the system does not behave as expected then the attacker may be tipped off that they are in a honeypot.  

The text editor should provide an environment like that of Nano. A list of features within Nano are as follows:
-	**Exit** This will prompt the user to save the document and provide the option to change the name of the document and once saved it will exit nano.
-	**Write Out** This saves the file, the file must be saved with the correct permissions based off the user permissions. This also prompts the user to name the file that is being saved. The text box will have the current file name if there is one and ask the user to confirm if they want to change it from the original. 
-	**Read File** This allows the user to open a file and load the text content into the editor.
-	**Where is** This allows the user to find a string within the document.
-	**Replace** This finds and replaces a string with another string.
-	**Cut** This copies a highlighted string and remove the text from the screen.
-	**Paste** This pastes a cut or copied string at the position of the curser.

The user experience and interface within the text editor needs to mimic Nano, this includes a highlighted dynamic output at the bottom of the screen. This will need to provide information of how many lines are in the document when it is opened. 

#### 1.3.3 User Characteristics   

The Cowrie honeypot system is designed to capture SSH and Telnet connections, as well as record the session information. Cowrie is primarily used by researchers, however Cowrie can be used by individuals or companies that need to track real-time hacking attempts. Researchers are interested in Cowrie because it is seen as a valuable security technique that can be implemented to mitigate attacks and it also provides an opportunity to learn more detail about the nature of these attacks. Researchers can then examine these interactions to learn about new tools, tactics, and processes used by attackers. This resulting analysis then helps them create actionable cybersecurity intelligence and then remediate and secure the information security of the infrastructure. Hackers may also use Cowrie on other hackers, hoping adversaries will accidentally leak data that identifies them. Government agencies, law enforcement and defense networks can use Cowrie to create a trap for hostile hackers and get them to reveal their techniques.   
Another use of Cowrie for researchers is a tool to gather data about attacks. For example, the lessons learned from the attacks can be used to build even better or stronger defense mechanisms to improve security.
This knowledge can also be used to improve other honeypots or the system itself. In addition, new systems other than honeypots may be developed in future using this knowledge. Research helps to increase our understanding of deception techniques and can be used as a pivot for planning, configuring, and testing the default Cowrie configuration file to increase its deceptive capabilities when presented to attackers.
The use of honeypots such as Cowrie is becoming increasingly more common in terms of studying how attackers penetrate into information security systems. From this, researchers can learn and analyze new threats and attack methodologies to counter and defend ourselves from cyber-attackers.

#### 1.3.4 Limitations

The Cowrie honeypot is a helpful tool for observing the attackers behavior, but it has some areas that need improvement, which are listed below.

**a) Lack of a persistent filesystem:** The Cowrie honeypot has issues with the maintaining changes into the file system for an individual. When an attacker tries to make changes to the file system, such as adding and removing any folders, files, or directories a good honeypot should be able to maintain that information, so that the attacker will be able to see these changes. A lack of changes to this system will indicate to the attacker that they are in a honeypot. Cowrie should also maintain metadata of the file system such as: last modified date, last modified by, owner of the file or directory - this information should remain the same.

**b) Default state of Cowrie honeypot is easily finger printable:** The Cowrie honeypot is currently unable to be easily customised by the user, meaning the attackers can discover the honeypot.

**c) Cowrie has a limited range of realistic IoT device profiles:** IoT devices are favourable tools for the attackers as there are greater chances that these are not configured properly. Cowrie has limited realistic profiles for the IoT devices, which makes it easily finger printable.

**d) Limited Documentation:** As it is an open source project and it is not maintained by a dedicated team, there is a lack of documentation. Whenever anyone makes changes to its source code, there is a high chance that it may not have gone through the quality assurance process. This makes it difficult for new developers to edit and contribute to the code, as there is a severe lack of documentation.

**e) Source Code Complexity:** Since the start of the project more than 100 developers have contributed to the original Cowrie project. Due to lack of the co-ordination of these developers, over time an unnecessary level of complexity has been introduced. 


## 2. References

References to other documents or standards. Follow the IEEE Citation  Reference scheme, available from the [IEEE website](https://www.ieee.org/) (please use the search box). (1 page, longer if required)

## 3. Specific requirements  

20 pages outlining the requirements of the system. You should apportion these pages across the following subsections to focus on the most important parts of your product.

### 3.1 External interfaces

See 9.5.10. for most systems this will be around one page. 

### 3.2 Functions

This is typically the longest subsection in the document. List up to fifty use cases (in order of priority for development), and for at least top ten focal use cases, write a short goal statement and use case body (up to seven pages).  Identify the use cases that comprise a minimum viable product.

### 3.3 Usability Requirements

See 9.5.12. for most systems this will be around one page.

> **9.5.12 Usability requirements**<br>
> Define usability (quality in use) requirements. Usability requirements and objectives for the software system include measurable effectiveness, efficiency, and satisfaction criteria in specific contexts of use.

### 3.4 Performance requirements

See 9.5.13. for most systems this will be around one page. Hardware projects also see section 9.4.6.

> **9.5.13 Performance requirements** <br>
> Specify both the static and the dynamic numerical requirements placed on the software or on human interaction with the software as a whole. 
> 
> Static numerical requirements may include the following:
> 
> a) The number of terminals to be supported;  
> b) The number of simultaneous users to be supported;  
> c) Amount and type of information to be handled.
> 
> Static numerical requirements are sometimes identified under a separate section entitled Capacity.
> 
> Dynamic numerical requirements may include, for example, the numbers of transactions and tasks and the amount of data to be processed within certain time periods for both normal and peak workload conditions. The performance requirements should be stated in measurable terms.
> 
>  For example, "_95 % of the transactions shall be processed in less than 1 second._" rather than, "An operator shall not have to wait for the transaction to complete."
> 
> NOTE Numerical limits applied to one specific function are normally specified as part of the processing subparagraph description of that function.


### 3.5 Logical database requirements

See 9.5.14. for most systems, a focus on d) and e) is appropriate, such as an object-oriented domain analysis. You should provide an overview domain model (e.g.  a UML class diagram of approximately ten classes) and write a brief description of the responsibilities of each class in the model (3 pages).

### 3.6 Design constraints

see 9.5.15 and 9.5.16. for most systems, this will be around one page.

> 9.5.15 Design constraints<br>
> Specify constraints on the system design imposed by external standards, regulatory requirements, or project limitations.
> 
> 9.5.16 Standards compliance<br>
> Specify the requirements derived from existing standards or regulations, including:
> 
> a) Report format;<br>
> b) Data naming;<br>
> c) Accounting procedures;<br>
> d) Audit tracing.
> 
> For example, this could specify the requirement for software to trace processing activity. Such traces are needed for some applications to meet minimum regulatory or financial standards. An audit trace requirement may, for example, state that all changes to a payroll database shall be recorded in a trace file with before and after values.

### 3.7 Nonfunctional system attributes

Present the systemic (aka nonfunctional) requirements of the product (see ISO/IEC 25010).
List up to twenty systemic requirements / attributes.
Write a short natural language description of the top nonfunctional requirements (approx. five pages).


### 3.8 Physical and Environmental Requirements 

For systems with hardware components, identify the physical characteristics of that hardware (9.4.10) and environment conditions in which it must operate (9.4.11).  Depending on the project, this section may be from one page up to 5 pages.

### 3.9 Supporting information

see 9.5.19. 

## 4. Verification

3 pages outlining how you will verify that the product meets the most important specific requirements. The format of this section should parallel section 3 of your document (see 9.5.18). Wherever possible (especially systemic requirements) you should indicate testable acceptance criteria.

## 5. Development schedule.

### 5.1 Schedule

Identify dates for key project deliverables: 

1. architectural prototype
1. minimum viable product
1. further releases

(1 page).

### 5.2 Budget

Present a budget for the project (table), and justify each budget item (one paragraph per item, one page overall). 

### 5.3 Risks 

Identify the ten most important project risks to achieving project goals: their type, likelihood, impact, and mitigation strategies (3 pages).

If the project will involve any work outside the ECS laboratories, i.e. off-campus activities, these should be included in the following section.

### 5.4 Health and Safety

Document here project requirements for Health and Safety. All teams must state in this section:

1. How teams will manage computer-related risks such as Occupational Over Use, Cable management, etc.  

2. Whether project work requires work or testing at any external (off-campus) workplaces/sites. If so, state the team's plans for receiving a Health and Safety induction for the external workplaces/sites. If the team has already received such an induction, state the date it was received. 

3. Whether project work requires the team test with human or animal subjects? If so, explain why there is no option but for the team to perform this testing, and state the team's plans for receiving Ethics Approval _prior_ to testing.

Also document in this section any additional discussions with the School Safety Officer regarding Health and Safety risks. Give any further information on relevant health and safety regulations, risks, and mitigations, etc.


#### 5.4.1 Safety Plans

Project requirements do not involve risk of death, serious harm, harm or injury

## 6. Appendices
### 6.1 Assumptions and dependencies 

One page on assumptions and dependencies (9.5.7).

### 6.2 Acronyms and abbreviations

Here is the list of Acronyms and abbreviations used in this document.
####List of Acronyms

|Acronym  |	Category/ stands for |
|---------|----------------------|
|e.g.|Latin abbreviations|
|Kbs|Knowledge based system| 
|UML|Unified Modeling Language|
|ENGR301|Engineering301|
|ssh|Secure Shell|
|CLI|Command line interface|
|ECS|Engineering computer science|

####List of abbreviations

|Abbreviation  |Stands for |
|---------|----------------------|
|etc.|et cetera (means and so on)|
|sync|Synchronization, synchronize| 
|i.e.|Id est (means that is) Used to clarify or specify something in parentheses|


## 7. Contributions

A one page statement of contributions, including a list of each member of the group and what they contributed to this document.

---

## Formatting Rules 

 * Write your document using [Markdown](https://gitlab.ecs.vuw.ac.nz/help/user/markdown#gitlab-flavored-markdown-gfm) and ensure you commit your work to your team's GitLab repository.
 * Major sections should be separated by a horizontal rule.


## Assessment  

The goal of a requirements document is the problem you are attempting to solve:  not a first attempt at a solution to that problem. The most important factor in the assessmernt of the document is how will it meet that goal. The document will be assessed for both presentation and content. 

The presentation will be based on how easy it is to read, correct spelling, grammar, punctuation, clear diagrams, and so on.

The content will be assessed according to its clarity, consistency, relevance, critical engagement and a demonstrated understanding of the material in the course. We look for evidence these traits are represented and assess the level of performance against these traits. While being comprehensive and easy to understand, this document must be reasonably concise too. You will be affected negatively by writing a report with too many pages (far more than what has been suggested for each section above).

We aim to evaluate ENGR301 documents and projects as if they were real projects rather than academic exercises &mdash; especially as they are real projects with real clients. The best way to get a good mark in a document is to do the right thing for your project, your client, and your team. We encourage you to raise questions with your tutor or course staff, as soon as possible, so you can incorporate their feedback into your work.

---
