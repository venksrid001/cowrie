# ENGR 301: Project Requirements Document

The aim of this document is to specify the requirements of the system your group is to build. The focus of a requirements document is the problem you are attempting to solve:  not a first attempt at a solution to that problem. This document should communicate clearly to the supervisor, client and course coordinator what the system you build is going to do, and what constraints it must meet while doing so.

The document should also demonstrate your understanding of the main analysis principles and quality guidelines, and applicable standards, using tools and notations as necessary to communicate the requirements precisely, unambiguously and clearly in a written technical document. Page specifications below are *limits not targets* and refer to the pages in the PDF generated from the markdown. Because the size of your document is necessarily limited, you should ensure that you focus your efforts on those requirements that are most important to completing a successful system: if sections are at their page limit, indicate how many items would be expected in a complete specification. 

The ENGR 301 project proposal and requirements document should be based on the standard ISO/IEC/IEEE 29148:2011(E), primarily sections 8.4 and 9.5, plus section 9.4 for projects involving hardware and ISO 25010 SQuaRE for systemic requirements. While excerpts from the standard have been quoted within the template, to understand what is required it will be necessary to read earlier sections of the standards themselves. A supplementary treatment of requirements gathering in engineering projects may be found in [Requirements in Engineering Projects](https://victoria.rl.talis.com/items/F166DA94-DAD8-FBDB-0785-7A63C9BA3603.html?referrer=%2Flists%2F5886F297-2506-1F17-45D9-7F04CEE284EE.html%23item-F166DA94-DAD8-FBDB-0785-7A63C9BA3603) (Talis). The requirements document should contain the sections listed below, and conform to the formatting rules listed at the end of this brief. 

All team members are expected to contribute equally to the document and list their contributions in section 6 of the document. You should work on your document in your team's GitLab repository in a directory called `M1_Requirements`. While collective contributions are expected to be the exception rather than the rule, if more than one team member has contributed to a particular  commit then all those team member IDs should be included in the first line of the git commit message. `git blame`, `git diff`, file histories, etc. will be tools used to assess individual contributions, so everyone is encouraged to contribute individually, commit early and commit often. Any team wishing to separate individually contributed sections into a single file before collation into the single proposal document for submission is welcome to do so.

---

<div style="page-break-after: always;"></div>

# ENGR 301 Project Supercharged Cowrie Project Proposal and Requirements Document
#### Lucy Carver, Sridhar Venkatesh, Thomas Yang, Shruti Raja, Selby Dasent, Deepika Raheja

## 1. Introduction

The Supercharged Cowrie project is expected to expand the current capability of the Cowrie honeypot server, which is utilized to bait cyber attacks. The Cowrie system logs attackers' behaviour to help inform the user how to be better prepared for future attacks, when designing other systems. 

### Client

Client:  Masood Mansoori, PhD. M.Sc. B.Sc. <br>
Contact Details: <br>
Email: masood.mansoori@vuw.ac.nz <br>
Work Phone: 04 886 5369 <br>
University Office: CO 130, Cotton Building 

### 1.1 Purpose

The purpose of this project is to extend the functionality of the Cowrie system. The purpose of the extensions is to simulate functions of a real operating system, to entice cyber attacks and log the data generated by these attacks. 

### 1.2 Scope

The scope of the Supercharged Cowrie system will be fairly elementary. The Client has stated they do not wish for a fully-fledged editor, with reliance on external libraries; but rather an editor that runs on basic script and can fulfill basic editing functionalities. These functionalities include typical commands taht come with simulating an operating system, for example: nano, pwd, mkdir, whoami etc.

### 1.3 Product Overview 
#### 1.3.1 Product Perspective

Cowrie is a medium level interaction honeypot server, derived from Kippo. Kippo was another medium level interaction server developed with Python, which was primarily used to log brute force attacks and any sort of shell interaction performed by the attacker. Similar to Cowrie, Kippo also presents a fake file system for the attacker to work with. Along with a fake file system, Kippo also provides a file named userdb.txt, which allows the user of Kippo to edit any possible password and username combinations for the attacker to work with. This file can be overwritten and added to when necessary. The commands performed by an attacker (when logged into Kippo) are immediately captured and saved into a log file. Kippo also presents the utility to replay these log files at the live speed in which they were performed by the attacker.  

Kippo is no longer under active development, and most of its file structure, functionality and library dependancies have been utilised for the implementation of Cowrie. Cowrie is considered an extension of the functionalities of Kippo, as it is more capable of emulating the functionalities of an operating system and supports a wider range of commands. 

The Supercharged Cowrie project plans to implement specific commands and ensure that the Cowrie is able to provide dynamic output for those possible commands that an attacker may perform. Specifically the whoami command and the ability to provide a command line text editor that runs from its own script. The whoami command needs to produce expected results depending on whoever the attacker is logged in as. It is expected to create support for a text editor that runs from no library dependancies and is able to emulate the functionality of the nano editor (currently in Linux CLIs), while running off its own independant script. 


**User interfaces:** 

Operates within the command line interface. Should allow for editing files within the command line for Windows and Unix certified systems. 

**CPU/Memory**

Memory usage has not been documented as of yet. However there is an existence of a meminfo file, to allow the attacker to monitor how the memory is being used whilst logged into Cowrie. Cowrie simulates the internal storage of different IoT devices to further enhance it's simulation of the internal, configuration files and file structure. Hence when an attacker wants to read the meminfo file, they will be provided with memory storage/cpu/OS that the IoT devices that have been simulated for Cowrie. Memory should be persistent to the extent, that an attacker will be able to view a history of their previous commands performed whilst logged into Cowrie. There should also be at least metadata of the files that were created in the last session where the attacker previously logged on, there should be some trace of the data that was created by the attacker while logged into the honeypot. 



#### 1.3.2 Product functions

Cowrie currently has a number of features that allow it to operate as a honeypot. This project will be expanding on these to improve its functionality. These functions will build off existing commands and utilities within a Unix system but be created to operate within Cowrie.

The first function will be a dynamic whoami command. Whoami is a basic Unix command and Windows command that is used within the CLI to display the username of who is logged in. Cowrie does currently have a response to the whoami command; however, this command has a fixed response of root. To make this command dynamic it will need to produce a response based of the username of who is logged in. This will improve the deceptiveness of the Cowrie honeypot for those that log into it. 

The second function that will be added is that of a CLI text editor. A common tactic for attackers when accessing a system is to open a text editor and edit/save a file, if the system does not behave as expected then the attacker nay be tipped off that they are in a honeypot.  

The text editor should provide an environment like that of Nano. A list of features within Nano are as follows:
-	**Exit** this will prompt the user to save the document and provide the option to change the name of the document and once saved it will exit nano.
-	**Write Out** save the file, the file must be saved with the correct permissions based of the user permissions. This also prompt the user the name the file that is being saved, the text box will have the current file name if there is one and ask the user to confirm if they change it from the original. 
-	**Read File** allow the user to open a file and load the text content into the editor.
-	**Where is** allow the user to find a string within the document.
-	**replace** find and replace a string with another string.
-	**Cut** copy a highlighted string and remove the text from the screen.
-	**Paste** paste a cut or copied string at the position of the curser.

The user experience and interface within the text editor needs to mimic Nano, this includes a highlighted dynamic output at the bottom of the screen. This will need to provide information of how many lines in the document when it is opened. 

#### 1.3.3 User characteristics   

The Cowrie honeypot system is designed to capture SSH and Telnet connections, as well as record the session information. 
Cowrie is primarily used by researchers, however, is not limited to. For example,
Cowrie can be used by individuals or companies that need to track real-time hacking attempts and it can provide some form of defense to the real system. The attacker may be diverted away from the actual system into the honeypot. 
Hackers use Cowrie on other hackers, hoping adversaries will accidentally leak data that identifies them. 
Law enforcement may use Cowrie honeypot to catch criminals.
Government agencies and defense networks can use Cowrie to create a trap for hostile hackers and get them to reveal their techniques.
The main users of Cowrie are researchers. Researchers are interested in Cowrie because it is seen as a valuable security technique that can be implemented to mitigate attacks and it also provides an opportunity to learn more detail about the nature of these attacks. Researchers can then examine these interactions to learn about new tools, tactics, and processes used by attackers. This resulting analysis then helps them create actionable cybersecurity intelligence and then remediate and secure the information security of the infrastructure. 
Using honeypots such as Cowrie is increasingly common for studying how attackers penetrate into information security systems. From this, researchers can learn and analyze new threats and attack methodologies to counter and defend ourselves from cyber-attackers. 
Another use of Cowrie for researchers is a tool to gather data about attacks. For example, the lessons learned from the attacks can be used to build even better or stronger defense mechanisms to improve security.
This knowledge can also be used to improve other honeypots or the system itself. In addition, new systems other than honeypots may be developed in future using this knowledge. Research helps to increase our understanding of deception techniques and can be used as a pivot for planning, configuring, and testing the default Cowrie configuration file to increase its deceptive capabilities when presented to attackers.

#### 1.3.4 Limitations

Cowrie honeypot is a helpful tool for observing the attackers behavior, but it has some areas of impprovements, as listed below:

**a) Lack of a persistent filesystem:** Cowrie honeypot has issues with the maintaining state of the changes into the file system for an individual. A good honeypot is the one where an attacker tries to make changes to the file system, such as adding and removing any folders, files, or directories and it should be able to maintain that information. So that the attacker should be able to see the same changes as before. Otherwise, attacker will be able to find out that is a honeypot. Metadata of the file system, like: last modified date, last modified by, owner of the file or directory should also remains same. Cowrie honeypot has this limitation which needs to be improved so that attacker can be decevied and continue to interact for the longer time.

**b) Default state of Cowrie honeypot is easily finger printable:** Out of the box cowrie honeypot is easily detectable by the attackers so it needs to be customised to make it smart solution so that attacker can be convenience that he is dealing with real system rather than a honeypot.

**c) Cowrie has limited range of realistic IoT device profiles:** IoT devices are one of the favourite tools for the attackers as there are greater chances that these are not configured properly. But Cowrie has limited realistic profiles for the IoT devices, which makes it easily finger printable.

**d) Limited Documentation:** As it is an open source project and it is not maintained by dedicated team. Whenever anyone makes changes to its source code, there are highly chances that it may not be gone through the QA process, and it might have missed to reflect the latest changes into its documentation. Which makes life difficult for the new commers, those wanted to understand and do required changes for the enhancements.

**e) Source Code Complexity:** Since the start of the project more than 100 developers have contributed into this project. Over the time, due to lack of the co-ordination of these developers, unnecessary level of complexity has been introduced. 


## 2. References

References to other documents or standards. Follow the IEEE Citation  Reference scheme, available from the [IEEE website](https://www.ieee.org/) (please use the search box). (1 page, longer if required)

## 3. Specific requirements  

20 pages outlining the requirements of the system. You should apportion these pages across the following subsections to focus on the most important parts of your product.

### 3.1 External interfaces

See 9.5.10. for most systems this will be around one page. 

### 3.2 Functions

This is typically the longest subsection in the document. List up to fifty use cases (in order of priority for development), and for at least top ten focal use cases, write a short goal statement and use case body (up to seven pages).  Identify the use cases that comprise a minimum viable product.

### 3.3 Usability Requirements

See 9.5.12. for most systems this will be around one page.

> **9.5.12 Usability requirements**<br>
> Define usability (quality in use) requirements. Usability requirements and objectives for the software system include measurable effectiveness, efficiency, and satisfaction criteria in specific contexts of use.

### 3.4 Performance requirements

See 9.5.13. for most systems this will be around one page. Hardware projects also see section 9.4.6.

> **9.5.13 Performance requirements** <br>
> Specify both the static and the dynamic numerical requirements placed on the software or on human interaction with the software as a whole. 
> 
> Static numerical requirements may include the following:
> 
> a) The number of terminals to be supported;  
> b) The number of simultaneous users to be supported;  
> c) Amount and type of information to be handled.
> 
> Static numerical requirements are sometimes identified under a separate section entitled Capacity.
> 
> Dynamic numerical requirements may include, for example, the numbers of transactions and tasks and the amount of data to be processed within certain time periods for both normal and peak workload conditions. The performance requirements should be stated in measurable terms.
> 
>  For example, "_95 % of the transactions shall be processed in less than 1 second._" rather than, "An operator shall not have to wait for the transaction to complete."
> 
> NOTE Numerical limits applied to one specific function are normally specified as part of the processing subparagraph description of that function.


### 3.5 Logical database requirements

See 9.5.14. for most systems, a focus on d) and e) is appropriate, such as an object-oriented domain analysis. You should provide an overview domain model (e.g.  a UML class diagram of approximately ten classes) and write a brief description of the responsibilities of each class in the model (3 pages).

### 3.6 Design constraints

see 9.5.15 and 9.5.16. for most systems, this will be around one page.

> 9.5.15 Design constraints<br>
> Specify constraints on the system design imposed by external standards, regulatory requirements, or project limitations.
> 
> 9.5.16 Standards compliance<br>
> Specify the requirements derived from existing standards or regulations, including:
> 
> a) Report format;<br>
> b) Data naming;<br>
> c) Accounting procedures;<br>
> d) Audit tracing.
> 
> For example, this could specify the requirement for software to trace processing activity. Such traces are needed for some applications to meet minimum regulatory or financial standards. An audit trace requirement may, for example, state that all changes to a payroll database shall be recorded in a trace file with before and after values.

### 3.7 Nonfunctional system attributes

Present the systemic (aka nonfunctional) requirements of the product (see ISO/IEC 25010).
List up to twenty systemic requirements / attributes.
Write a short natural language description of the top nonfunctional requirements (approx. five pages).


### 3.8 Physical and Environmental Requirements 

For systems with hardware components, identify the physical characteristics of that hardware (9.4.10) and environment conditions in which it must operate (9.4.11).  Depending on the project, this section may be from one page up to 5 pages.

### 3.9 Supporting information

see 9.5.19. 

## 4. Verification

3 pages outlining how you will verify that the product meets the most important specific requirements. The format of this section should parallel section 3 of your document (see 9.5.18). Wherever possible (especially systemic requirements) you should indicate testable acceptance criteria.

## 5. Development schedule.

### 5.1 Schedule

Identify dates for key project deliverables: 

1. architectural prototype
1. minimum viable product
1. further releases

(1 page).

### 5.2 Budget

Present a budget for the project (table), and justify each budget item (one paragraph per item, one page overall). 

### 5.3 Risks 

Identify the ten most important project risks to achieving project goals: their type, likelihood, impact, and mitigation strategies (3 pages).

If the project will involve any work outside the ECS laboratories, i.e. off-campus activities, these should be included in the following section.

### 5.4 Health and Safety

Document here project requirements for Health and Safety. All teams must state in this section:

1. How teams will manage computer-related risks such as Occupational Over Use, Cable management, etc.  

2. Whether project work requires work or testing at any external (off-campus) workplaces/sites. If so, state the team's plans for receiving a Health and Safety induction for the external workplaces/sites. If the team has already received such an induction, state the date it was received. 

3. Whether project work requires the team test with human or animal subjects? If so, explain why there is no option but for the team to perform this testing, and state the team's plans for receiving Ethics Approval _prior_ to testing.

Also document in this section any additional discussions with the School Safety Officer regarding Health and Safety risks. Give any further information on relevant health and safety regulations, risks, and mitigations, etc.


#### 5.4.1 Safety Plans

Safety Plans may be required for some projects, depending on project requirements. Safety Plan templates are available on the course Health & Safety page. Two questions all teams must answer are:

**Do project requirements involve anything that can cause serious harm or death?**  
Examples: building/modifying devices using voltages > 60 V, chemicals, large moving machinery, flying devices, bodies of water.

If so, you will have to write a separate Safety Plan as part of project requirements, and the Safety Plan must be referenced in this section. For health and safety risks involving serious harm or death, you must first contact the School Safety Officer and Course Coordinator first to discuss the Safety Plan and project requirements.

**Do project requirements involve anything that can cause harm or injury?**  
Examples: building/modifying things with voltages <= 60V, small moving machinery, wearable devices.

If so, you will have to write a separate Safety Plan as part of project requirements, and the Safety Plan must be referenced in this section. For health and safety risks involving harm or injury, you should write a draft of the Safety Plan before contacting the School Safety Officer and Course Coordinator to discuss the Safety Plan and project requirements.

If a safety plan is required, list in this section the date the School Safety officer accepted your Health and Safety plan (if accepted by submission date).

_If the project is purely software and requires no contact risks involving physical harm, then state "Project requirements do not involve risk of death, serious harm, harm or injury." in this section._


## 6. Appendices
### 6.1 Assumptions and dependencies 

One page on assumptions and dependencies (9.5.7).

### 6.2 Acronyms and abbreviations

One page glossary _as required_.

## 7. Contributions

A one page statement of contributions, including a list of each member of the group and what they contributed to this document.

---

## Formatting Rules 

 * Write your document using [Markdown](https://gitlab.ecs.vuw.ac.nz/help/user/markdown#gitlab-flavored-markdown-gfm) and ensure you commit your work to your team's GitLab repository.
 * Major sections should be separated by a horizontal rule.


## Assessment  

The goal of a requirements document is the problem you are attempting to solve:  not a first attempt at a solution to that problem. The most important factor in the assessmernt of the document is how will it meet that goal. The document will be assessed for both presentation and content. 

The presentation will be based on how easy it is to read, correct spelling, grammar, punctuation, clear diagrams, and so on.

The content will be assessed according to its clarity, consistency, relevance, critical engagement and a demonstrated understanding of the material in the course. We look for evidence these traits are represented and assess the level of performance against these traits. While being comprehensive and easy to understand, this document must be reasonably concise too. You will be affected negatively by writing a report with too many pages (far more than what has been suggested for each section above).

We aim to evaluate ENGR301 documents and projects as if they were real projects rather than academic exercises &mdash; especially as they are real projects with real clients. The best way to get a good mark in a document is to do the right thing for your project, your client, and your team. We encourage you to raise questions with your tutor or course staff, as soon as possible, so you can incorporate their feedback into your work.

---
